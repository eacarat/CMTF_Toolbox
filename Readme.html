
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>The MATLAB CMTF Toolbox</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-07-28"><meta name="DC.source" content="test_examples.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>The MATLAB CMTF Toolbox</h1><!--introduction--><p>The MATLAB CMTF Toolbox has two different models based on Coupled Matrix and Tensor Factorizations to jointly analyze datasets of different orders: (i) CMTF [1] and (ii) ACMTF [2, 5]. First-order unconstrained optimization is used to fit both versions. The MATLAB CMTF Toolbox has the functions necessary to compute function values and gradients for CMTF and ACMTF. For the optimization routines, it uses the Poblano Toolbox [3] for unconstrained optimization, and also the LBFGSB implementation for nonnegativity constraints, available at https://github.com/stephenbeckr/L-BFGS-B-C. The Tensor Toolbox [4] is also needed to run the functions in the Matlab CMTF Toolbox. This page illustrates some example scripts, e.g., TESTER_CMTF, TESTER_ACMTF, TESTER_CMTF_MISSING, TESTER_ACMTF_MISSING showing the use of CMTF and ACMTF. For more details, explore CMTF_OPT and ACMTF_OPT.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">What is new?</a></li><li><a href="#2">CMTF (Coupled Matrix and Tensor Factorizations) using first-order optimization</a></li><li><a href="#3">ACMTF (Coupled Matrix and Tensor Factorization) using first-order optimization with the option of imposing sparsity penalties on the component weights</a></li><li><a href="#4">Joint Analysis of Incomplete Data Sets using CMTF/ACMTF</a></li><li><a href="#5">References</a></li></ul></div><h2 id="1">What is new?</h2><div><ol><li>Compatibility with the latest version of Tensor Toolbox and Poblano Toolbox</li><li>Option to impose constraints through the use of lbfgsb from https://github.com/stephenbeckr/L-BFGS-B-C</li></ol></div><h2 id="2">CMTF (Coupled Matrix and Tensor Factorizations) using first-order optimization</h2><p>Coupled Matrix and Tensor Factorizations model higher-order tensors using CANDECOMP/PARAFAC (CP) models and factorizes matrices jointly. TESTER_CMTF is an example script showing how to use CMTF.</p><pre class="codeinput"><span class="comment">% Example 1:</span>
<span class="comment">% Generate a third-order data set coupled with a matrix and fit a CMTF model.</span>
data = tester_cmtf([]);

<span class="comment">% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,</span>
<span class="comment">% i.e., data.Fac{i}. For example, for the first mode, i=1:</span>
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% Example 2:</span>
<span class="comment">% Generate a third-order tensor coupled with a matrix in the first mode and coupled with another matrix in the second mode. Three components are used</span>
<span class="comment">% to generate data.</span>
data = tester_cmtf([],<span class="string">'modes'</span>,{[1 2 3], [1 4], [2 5]}, <span class="string">'size'</span>, [30 10 20 40 50], <span class="string">'lambdas'</span>,{[1 1 1],[1 1 1], [1 1 1]}, <span class="string">'flag_sparse'</span>, [0 0 0], <span class="string">'flag_gnn'</span>, [0 0 0 0 0]);

<span class="comment">% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,</span>
<span class="comment">% i.e., data.Fac{i}. For example, for the first mode, i=1:</span>
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% Example 3:</span>
<span class="comment">% Generate a sparse third-order tensor coupled with a matrix stored in dense format and fit a CMTF model</span>
data = tester_cmtf([],<span class="string">'modes'</span>,{[1 2 3],[1 4]}, <span class="string">'size'</span>, [100 100 100 100],<span class="string">'flag_sparse'</span>,[1 0]);

<span class="comment">% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,</span>
<span class="comment">% i.e., data.Fac{i}. For example, for the first mode, i=1:</span>
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% Example 4:</span>
<span class="comment">% Generate a sparse third-order tensor coupled with a sparse matrix and fit a CMTF model</span>
data = tester_cmtf([],<span class="string">'modes'</span>,{[1 2 3],[1 4]}, <span class="string">'size'</span>, [100 100 100 100],<span class="string">'flag_sparse'</span>,[1 1]);

<span class="comment">% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,</span>
<span class="comment">% i.e., data.Fac{i}. For example, for the first mode, i=1:</span>
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% Example 5:</span>
<span class="comment">% Generate a third-order tensor coupled with a matrix and fit a CMTF model with/without nonnegativity constraints</span>
<span class="comment">% use lbfgsb - with no constraints on the factors</span>
data = tester_cmtf([], <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>);
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% use  lbfgsb - with factors generated to be nonnegative - CMTF has no constraints</span>
data  = tester_cmtf([], <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>, <span class="string">'flag_gnn'</span>, [1 1 1 1]);
corr(data.Fac{1}, data.Factrue{1})

<span class="comment">% use  lbfgsb - with factors generated to be nonnegative and constrained by the model to be nonnegative</span>
data_nn = tester_cmtf(data, <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>, <span class="string">'flag_gnn'</span>, [1 1 1 1], <span class="string">'flag_fnn'</span>,[1 1 1 1]);
corr(data_nn.Fac{1}, data.Factrue{1})

<span class="comment">% Example 6:</span>
<span class="comment">% Generate a sparse third-order tensor coupled with a sparse matrix with nonnegative factors, and fit a CMTF model with/without nonnegativity constraints</span>
<span class="comment">% without nonnegativity constraints</span>
data = tester_cmtf([],<span class="string">'modes'</span>,{[1 2 3],[1 4]}, <span class="string">'size'</span>, [100 100 100 100],<span class="string">'flag_sparse'</span>,[1 1], <span class="string">'flag_gnn'</span>, [1 1 1 1], <span class="string">'flag_fnn'</span>,[0 0 0 0]);

<span class="comment">% with nonnegativity constraints</span>
data = tester_cmtf([],<span class="string">'modes'</span>,{[1 2 3],[1 4]}, <span class="string">'size'</span>, [100 100 100 100],<span class="string">'flag_sparse'</span>,[1 1], <span class="string">'flag_gnn'</span>, [1 1 1 1], <span class="string">'flag_fnn'</span>,[1 1 1 1],<span class="string">'alg'</span>, <span class="string">'lbfgsb'</span>);
</pre><h2 id="3">ACMTF (Coupled Matrix and Tensor Factorization) using first-order optimization with the option of imposing sparsity penalties on the component weights</h2><p>Coupled Matrix and Tensor Factorizations model higher-order tensors using CANDECOMP/PARAFAC models and factorizes matrices jointly. Unlike CMTF, ACMTF enables the option of imposing sparsity penalties on the weights of components in order to identify shared/unshared components in coupled data sets. TESTER_ACMTF is an example script showing how to use ACMTF.</p><pre class="codeinput"><span class="comment">% Example 1:</span>
<span class="comment">% Generate a third-order tensor coupled with a matrix with one shared component and one unshared component in each data set,</span>
<span class="comment">% and fit an ACMTF model with penalties on the component weights.</span>
data = tester_acmtf([], <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>, [1e-3 1e-3]);

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data.lambda_rec

<span class="comment">% Example 2:</span>
<span class="comment">% Generate a sparse third-order tensor coupled with a sparse matrix with one shared component and one unshared component in each data set,</span>
<span class="comment">% and fit an ACMTF model with penalties on the component weights.</span>
data = tester_acmtf([],<span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>, [1e-3 1e-3],<span class="string">'flag_sparse'</span>,[1 1]);

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data.lambda_rec

<span class="comment">% Example 3:</span>
<span class="comment">% Generate a third-order tensor coupled with a matrix and fit an ACMTF model with/without nonnegativity constraints</span>
<span class="comment">% use lbfgsb - with no constraints on the factors but just lambdas constrained to be nonnegative</span>
data = tester_acmtf([], <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>,[1e-3 1e-3],<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>);

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data.lambda_rec

<span class="comment">% Example 4:</span>
<span class="comment">% Generate a third-order tensor coupled with a matrix and fit an ACMTF model with/without nonnegativity constraints</span>
<span class="comment">% use lbfgsb - data generated using nonnegative factors but no nonnegativity constraints imposed on the factors</span>
data  = tester_acmtf([], <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>,[1e-3 1e-3],<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>, <span class="string">'flag_gnn'</span>, [1 1 1 0]);
<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data.lambda_rec

<span class="comment">% use  lbfgsb - with factors generated to be nonnegative and constrained by the model to be nonnegative</span>
data_nn = tester_acmtf(data, <span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>,[1e-3 1e-3],<span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>, <span class="string">'flag_gnn'</span>, [1 1 1 0], <span class="string">'flag_fnn'</span>,[1 1 1 0]);
<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data_nn.Zhat{1});
Fac2 = normalize(data_nn.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data_nn.lambda_rec

<span class="comment">% Example 5:</span>
<span class="comment">% Generate a sparse third-order tensor coupled with a sparse matrix with one shared component and one unshared component in each data set, with</span>
<span class="comment">% nonnegative factor matrices and fit an ACMTF model without nonnegativity constraints.</span>
data = tester_acmtf([],<span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>, [1e-3 1e-3],<span class="string">'flag_sparse'</span>,[1 1], <span class="string">'flag_gnn'</span>, [1 1 1 0]);

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data.lambda_rec

<span class="comment">% Fit an ACMTF model to the same coupled data sets using nonnegativity constraints</span>
data_nn = tester_acmtf(data,<span class="string">'R'</span>,3,<span class="string">'size'</span>,[30 20 10 40], <span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]}, <span class="string">'modes'</span>,{[1 2 3],[1 4]},<span class="string">'beta'</span>, [1e-3 1e-3],<span class="string">'flag_sparse'</span>,[1 1], <span class="string">'alg'</span>,<span class="string">'lbfgsb'</span>, <span class="string">'flag_gnn'</span>, [1 1 1 0], <span class="string">'flag_fnn'</span>, [1 1 1 0]);

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data_nn.Zhat{1});
Fac2 = normalize(data_nn.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Check whether the weights reveal shared/unshared components</span>
data_nn.lambda_rec
</pre><h2 id="4">Joint Analysis of Incomplete Data Sets using CMTF/ACMTF</h2><p>TESTER_CMTF_MISSING and TESTER_ACMTF_MISSING are example scripts showing how to use CMTF and ACMTF with incomplete data sets.</p><pre class="codeinput"><span class="comment">% Example 1</span>
<span class="comment">% Generate a third-order tensor (with 50% of its entries missing) coupled with a matrix in the first mode.</span>
data = tester_cmtf_missing(<span class="string">'size'</span>,[20 30 40 50], <span class="string">'modes'</span>, {[1 2 3], [1 4]}, <span class="string">'R'</span>, 3, <span class="string">'M'</span>, [0.5 0]);

<span class="comment">% Compute the error between the true values of missing entries and the estimated values.</span>
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(ktensor(data.Fac(1:3)));
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,<span class="string">'*'</span>);xlabel(<span class="string">'True Values'</span>);ylabel(<span class="string">'Estimated Values'</span>); title(<span class="string">'Missing Data Estimation'</span>);
err     = norm(estval - trueval)/length(estval);

<span class="comment">% Example 2</span>
<span class="comment">% Generate a third-order tensor (with 50% of its entries missing) coupled with a matrix in the first mode with nonnegative factors and fit CMTF</span>
<span class="comment">% with nonnegativity constraints.</span>
data = tester_cmtf_missing(<span class="string">'size'</span>,[20 30 40 50], <span class="string">'modes'</span>, {[1 2 3], [1 4]}, <span class="string">'R'</span>, 3, <span class="string">'M'</span>, [0.5 0], <span class="string">'flag_gnn'</span>,[1 1 1 1], <span class="string">'flag_fnn'</span>, [1 1 1 1], <span class="string">'alg'</span>, <span class="string">'lbfgsb'</span>);

<span class="comment">% Compute the error between the true values of missing entries and the estimated values.</span>
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(ktensor(data.Fac(1:3)));
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,<span class="string">'*'</span>);xlabel(<span class="string">'True Values'</span>);ylabel(<span class="string">'Estimated Values'</span>); title(<span class="string">'Missing Data Estimation'</span>);
err     = norm(estval - trueval)/length(estval);

<span class="comment">% Example 3</span>
<span class="comment">% Generate a third-order tensor (with 80% of its entries missing) coupled with a matrix (with 50% of its entries missing) in the first mode. Both</span>
<span class="comment">% data sets are stored in sptensor form. Data sets have one shared and one unshared components.</span>
data = tester_acmtf_missing(<span class="string">'size'</span>,[20 30 40 50], <span class="string">'modes'</span>, {[1 2 3], [1 4]}, <span class="string">'R'</span>, 3, <span class="string">'M'</span>, [0.8 0.5],<span class="string">'flag_sparse'</span>,[1 1],<span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]},<span class="string">'beta'</span>, [1e-3 1e-3]);

<span class="comment">% Compute the error between the true values of missing entries and the estimated values.</span>
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(data.Zhat{1});
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,<span class="string">'*'</span>);xlabel(<span class="string">'True Values'</span>);ylabel(<span class="string">'Estimated Values'</span>);title(<span class="string">'Missing Data Estimation'</span>);
err     = norm(estval - trueval)/length(estval);

<span class="comment">%Check if the shared/unshared factors are identified accurately</span>
data.adjlambda_rec

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})

<span class="comment">% Example 4</span>
<span class="comment">% Generate a third-order tensor (with 20% of its entries missing) coupled</span>
<span class="comment">% with a matrix in the first mode. Data sets have one shared and one</span>
<span class="comment">% unshared components generated using nonnegative factors. Fit ACMTF model</span>
<span class="comment">% with nonnegativity constraints in all modes using lbfgsb.</span>
data = tester_acmtf_missing(<span class="string">'size'</span>,[20 30 40 50], <span class="string">'modes'</span>, {[1 2 3], [1 4]}, <span class="string">'R'</span>, 3, <span class="string">'M'</span>, [0.2 0],<span class="string">'lambdas'</span>,{[1 0 1],[0 1 1]},<span class="string">'beta'</span>, [1e-3 1e-3], <span class="string">'flag_gnn'</span>,[1 1 1 1], <span class="string">'flag_fnn'</span>, [1 1 1 1], <span class="string">'alg'</span>, <span class="string">'lbfgsb'</span>);
<span class="comment">% Compute the error between the true values of missing entries and the estimated values.</span>
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(data.Zhat{1});
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,<span class="string">'*'</span>);xlabel(<span class="string">'True Values'</span>);ylabel(<span class="string">'Estimated Values'</span>);title(<span class="string">'Missing Data Estimation'</span>);
err     = norm(estval - trueval)/length(estval);

<span class="comment">%Check if the shared/unshared factors are identified accurately</span>
data.adjlambda_rec

<span class="comment">% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue.</span>
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
<span class="keyword">for</span> i=1:3
    corr(Fac1{i},data.Atrue{i})
<span class="keyword">end</span>
corr(Fac2{2},data.Atrue{4})
</pre><h2 id="5">References</h2><div><ol><li>E. Acar, T. G. Kolda, and D. M. Dunlavy, <a href="http://arxiv.org/abs/1105.3422v1">All-at-once Optimization for Coupled Matrix and Tensor Factorizations</a>, KDD Workshop on Mining and Learning with Graphs, 2011 (arXiv:1105.3422v1).</li><li>E. Acar, A. J. Lawaetz, M. A. Rasmussen,and R. Bro, <a href="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6610925">Structure-Revealing Data Fusion Model with Applications in Metabolomics</a>, IEEE EMBC, pages 6023-6026, 2013.</li><li>D. M. Dunlavy, T. G. Kolda, and E. Acar, Poblano: A Matlab Toolbox for Gradient-Based Optimization, Available: https://github.com/sandialabs/poblano_toolbox, July 2020</li><li>Brett W. Bader, Tamara G. Kolda and others. MATLAB Tensor Toolbox, Available: https://gitlab.com/tensors/tensor_toolbox, July 2020.</li><li>E. Acar, E. E. Papalexakis, G. Gurdeniz, M. Rasmussen, A. J. Lawaetz, M. Nilsson, and R. Bro, <a href="http://www.biomedcentral.com/1471-2105/15/239">Structure-Revealing Data Fusion</a>, BMC Bioinformatics, 15: 239, 2014.</li></ol></div><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% The MATLAB CMTF Toolbox 
% The MATLAB CMTF Toolbox has two different models based on Coupled Matrix and Tensor Factorizations to jointly analyze datasets of different orders: 
% (i) CMTF [1] and (ii) ACMTF [2, 5]. First-order unconstrained optimization is used to fit both versions. The MATLAB CMTF Toolbox has the functions necessary to
% compute function values and gradients for CMTF and ACMTF. For the optimization routines, it uses the Poblano Toolbox [3] for unconstrained optimization, and also the 
% LBFGSB implementation for nonnegativity constraints, available at https://github.com/stephenbeckr/L-BFGS-B-C. The Tensor Toolbox [4] is also needed to run the functions 
% in the Matlab CMTF Toolbox. This page illustrates some example scripts, e.g., TESTER_CMTF, TESTER_ACMTF, TESTER_CMTF_MISSING, TESTER_ACMTF_MISSING showing the use of 
% CMTF and ACMTF. For more details, explore CMTF_OPT and ACMTF_OPT. 
%
%% What is new?
% # Compatibility with the latest version of Tensor Toolbox and Poblano Toolbox 
% # Option to impose constraints through the use of lbfgsb from https://github.com/stephenbeckr/L-BFGS-B-C 

%% CMTF (Coupled Matrix and Tensor Factorizations) using first-order optimization
% Coupled Matrix and Tensor Factorizations model higher-order tensors using CANDECOMP/PARAFAC (CP) models and factorizes matrices jointly.
% TESTER_CMTF is an example script showing how to use CMTF.

% Example 1:
% Generate a third-order data set coupled with a matrix and fit a CMTF model. 
data = tester_cmtf([]);

% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,
% i.e., data.Fac{i}. For example, for the first mode, i=1:
corr(data.Fac{1}, data.Factrue{1})

% Example 2:
% Generate a third-order tensor coupled with a matrix in the first mode and coupled with another matrix in the second mode. Three components are used
% to generate data.
data = tester_cmtf([],'modes',{[1 2 3], [1 4], [2 5]}, 'size', [30 10 20 40 50], 'lambdas',{[1 1 1],[1 1 1], [1 1 1]}, 'flag_sparse', [0 0 0], 'flag_gnn', [0 0 0 0 0]);

% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,
% i.e., data.Fac{i}. For example, for the first mode, i=1:
corr(data.Fac{1}, data.Factrue{1})

% Example 3:
% Generate a sparse third-order tensor coupled with a matrix stored in dense format and fit a CMTF model
data = tester_cmtf([],'modes',{[1 2 3],[1 4]}, 'size', [100 100 100 100],'flag_sparse',[1 0]);

% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,
% i.e., data.Fac{i}. For example, for the first mode, i=1:
corr(data.Fac{1}, data.Factrue{1})

% Example 4:
% Generate a sparse third-order tensor coupled with a sparse matrix and fit a CMTF model
data = tester_cmtf([],'modes',{[1 2 3],[1 4]}, 'size', [100 100 100 100],'flag_sparse',[1 1]);

% Check how well the true factors used to generate coupled data sets, i.e., data.Factrue{i}, match with the factor matrices extracted using CMTF,
% i.e., data.Fac{i}. For example, for the first mode, i=1:
corr(data.Fac{1}, data.Factrue{1})

% Example 5:
% Generate a third-order tensor coupled with a matrix and fit a CMTF model with/without nonnegativity constraints
% use lbfgsb - with no constraints on the factors 
data = tester_cmtf([], 'R',3,'size',[30 20 10 40], 'modes',{[1 2 3],[1 4]},'alg','lbfgsb'); 
corr(data.Fac{1}, data.Factrue{1})

% use  lbfgsb - with factors generated to be nonnegative - CMTF has no constraints
data  = tester_cmtf([], 'R',3,'size',[30 20 10 40], 'modes',{[1 2 3],[1 4]},'alg','lbfgsb', 'flag_gnn', [1 1 1 1]); 
corr(data.Fac{1}, data.Factrue{1})

% use  lbfgsb - with factors generated to be nonnegative and constrained by the model to be nonnegative
data_nn = tester_cmtf(data, 'R',3,'size',[30 20 10 40], 'modes',{[1 2 3],[1 4]},'alg','lbfgsb', 'flag_gnn', [1 1 1 1], 'flag_fnn',[1 1 1 1]); 
corr(data_nn.Fac{1}, data.Factrue{1})

% Example 6:
% Generate a sparse third-order tensor coupled with a sparse matrix with nonnegative factors, and fit a CMTF model with/without nonnegativity constraints
% without nonnegativity constraints
data = tester_cmtf([],'modes',{[1 2 3],[1 4]}, 'size', [100 100 100 100],'flag_sparse',[1 1], 'flag_gnn', [1 1 1 1], 'flag_fnn',[0 0 0 0]);

% with nonnegativity constraints
data = tester_cmtf([],'modes',{[1 2 3],[1 4]}, 'size', [100 100 100 100],'flag_sparse',[1 1], 'flag_gnn', [1 1 1 1], 'flag_fnn',[1 1 1 1],'alg', 'lbfgsb');

%% ACMTF (Coupled Matrix and Tensor Factorization) using first-order optimization with the option of imposing sparsity penalties on the component weights
% Coupled Matrix and Tensor Factorizations model higher-order tensors using CANDECOMP/PARAFAC models and factorizes
% matrices jointly. Unlike CMTF, ACMTF enables the option of imposing sparsity penalties on the weights of components
% in order to identify shared/unshared components in coupled data sets. TESTER_ACMTF is an example script showing how to use ACMTF.

% Example 1:
% Generate a third-order tensor coupled with a matrix with one shared component and one unshared component in each data set, 
% and fit an ACMTF model with penalties on the component weights.
data = tester_acmtf([], 'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta', [1e-3 1e-3]);

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data.lambda_rec

% Example 2:
% Generate a sparse third-order tensor coupled with a sparse matrix with one shared component and one unshared component in each data set, 
% and fit an ACMTF model with penalties on the component weights.
data = tester_acmtf([],'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta', [1e-3 1e-3],'flag_sparse',[1 1]);

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data.lambda_rec

% Example 3:
% Generate a third-order tensor coupled with a matrix and fit an ACMTF model with/without nonnegativity constraints
% use lbfgsb - with no constraints on the factors but just lambdas constrained to be nonnegative
data = tester_acmtf([], 'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta',[1e-3 1e-3],'alg','lbfgsb'); 

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data.lambda_rec

% Example 4:
% Generate a third-order tensor coupled with a matrix and fit an ACMTF model with/without nonnegativity constraints
% use lbfgsb - data generated using nonnegative factors but no nonnegativity constraints imposed on the factors 
data  = tester_acmtf([], 'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta',[1e-3 1e-3],'alg','lbfgsb', 'flag_gnn', [1 1 1 0]); 
% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data.lambda_rec

% use  lbfgsb - with factors generated to be nonnegative and constrained by the model to be nonnegative
data_nn = tester_acmtf(data, 'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta',[1e-3 1e-3],'alg','lbfgsb', 'flag_gnn', [1 1 1 0], 'flag_fnn',[1 1 1 0]); 
% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data_nn.Zhat{1});
Fac2 = normalize(data_nn.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data_nn.lambda_rec

% Example 5:
% Generate a sparse third-order tensor coupled with a sparse matrix with one shared component and one unshared component in each data set, with
% nonnegative factor matrices and fit an ACMTF model without nonnegativity constraints.
data = tester_acmtf([],'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta', [1e-3 1e-3],'flag_sparse',[1 1], 'flag_gnn', [1 1 1 0]);

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data.lambda_rec

% Fit an ACMTF model to the same coupled data sets using nonnegativity constraints
data_nn = tester_acmtf(data,'R',3,'size',[30 20 10 40], 'lambdas',{[1 0 1],[0 1 1]}, 'modes',{[1 2 3],[1 4]},'beta', [1e-3 1e-3],'flag_sparse',[1 1], 'alg','lbfgsb', 'flag_gnn', [1 1 1 0], 'flag_fnn', [1 1 1 0]);

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data_nn.Zhat{1});
Fac2 = normalize(data_nn.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Check whether the weights reveal shared/unshared components
data_nn.lambda_rec


%% Joint Analysis of Incomplete Data Sets using CMTF/ACMTF
% TESTER_CMTF_MISSING and TESTER_ACMTF_MISSING are example scripts showing how to use CMTF and ACMTF with incomplete data sets.

% Example 1
% Generate a third-order tensor (with 50% of its entries missing) coupled with a matrix in the first mode.
data = tester_cmtf_missing('size',[20 30 40 50], 'modes', {[1 2 3], [1 4]}, 'R', 3, 'M', [0.5 0]);

% Compute the error between the true values of missing entries and the estimated values.
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(ktensor(data.Fac(1:3)));
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,'*');xlabel('True Values');ylabel('Estimated Values'); title('Missing Data Estimation');
err     = norm(estval - trueval)/length(estval);

% Example 2
% Generate a third-order tensor (with 50% of its entries missing) coupled with a matrix in the first mode with nonnegative factors and fit CMTF
% with nonnegativity constraints.
data = tester_cmtf_missing('size',[20 30 40 50], 'modes', {[1 2 3], [1 4]}, 'R', 3, 'M', [0.5 0], 'flag_gnn',[1 1 1 1], 'flag_fnn', [1 1 1 1], 'alg', 'lbfgsb');

% Compute the error between the true values of missing entries and the estimated values.
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(ktensor(data.Fac(1:3)));
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,'*');xlabel('True Values');ylabel('Estimated Values'); title('Missing Data Estimation');
err     = norm(estval - trueval)/length(estval);

% Example 3
% Generate a third-order tensor (with 80% of its entries missing) coupled with a matrix (with 50% of its entries missing) in the first mode. Both
% data sets are stored in sptensor form. Data sets have one shared and one unshared components.
data = tester_acmtf_missing('size',[20 30 40 50], 'modes', {[1 2 3], [1 4]}, 'R', 3, 'M', [0.8 0.5],'flag_sparse',[1 1],'lambdas',{[1 0 1],[0 1 1]},'beta', [1e-3 1e-3]);

% Compute the error between the true values of missing entries and the estimated values.
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(data.Zhat{1});
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,'*');xlabel('True Values');ylabel('Estimated Values');title('Missing Data Estimation');
err     = norm(estval - trueval)/length(estval);

%Check if the shared/unshared factors are identified accurately
data.adjlambda_rec

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})

% Example 4
% Generate a third-order tensor (with 20% of its entries missing) coupled 
% with a matrix in the first mode. Data sets have one shared and one
% unshared components generated using nonnegative factors. Fit ACMTF model
% with nonnegativity constraints in all modes using lbfgsb.
data = tester_acmtf_missing('size',[20 30 40 50], 'modes', {[1 2 3], [1 4]}, 'R', 3, 'M', [0.2 0],'lambdas',{[1 0 1],[0 1 1]},'beta', [1e-3 1e-3], 'flag_gnn',[1 1 1 1], 'flag_fnn', [1 1 1 1], 'alg', 'lbfgsb');
% Compute the error between the true values of missing entries and the estimated values.
trueval = data.Xorig{1}(find(data.W{1}==0));
Z       = full(data.Zhat{1});
estval  = Z(find(data.W{1}==0));
plot(trueval,estval,'*');xlabel('True Values');ylabel('Estimated Values');title('Missing Data Estimation');
err     = norm(estval - trueval)/length(estval);

%Check if the shared/unshared factors are identified accurately
data.adjlambda_rec

% Check how well extracted factors, i.e., Fac1 and Fac2, match with the original ones, data.Atrue. 
Fac1 = normalize(data.Zhat{1});
Fac2 = normalize(data.Zhat{2});
for i=1:3
    corr(Fac1{i},data.Atrue{i})    
end
corr(Fac2{2},data.Atrue{4})


%% References
% # E. Acar, T. G. Kolda, and D. M. Dunlavy, <http://arxiv.org/abs/1105.3422v1 All-at-once Optimization for
% Coupled Matrix and Tensor Factorizations>, KDD Workshop on Mining and Learning with Graphs, 2011 (arXiv:1105.3422v1).
% # E. Acar, A. J. Lawaetz, M. A. Rasmussen,and R. Bro, <http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6610925 Structure-Revealing Data Fusion Model with Applications in Metabolomics>, IEEE EMBC, pages 6023-6026, 2013.
% # D. M. Dunlavy, T. G. Kolda, and E. Acar, Poblano: A Matlab Toolbox for Gradient-Based Optimization, Available: https://github.com/sandialabs/poblano_toolbox, July 2020
% # Brett W. Bader, Tamara G. Kolda and others. MATLAB Tensor Toolbox, Available: https://gitlab.com/tensors/tensor_toolbox, July 2020.
% # E. Acar, E. E. Papalexakis, G. Gurdeniz, M. Rasmussen, A. J. Lawaetz, M. Nilsson, and R. Bro, <http://www.biomedcentral.com/1471-2105/15/239 Structure-Revealing Data Fusion>, BMC Bioinformatics, 15: 239, 2014.        

##### SOURCE END #####
--></body></html>